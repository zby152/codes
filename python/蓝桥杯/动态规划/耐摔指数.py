import os
import sys
# 题目已知条件，最佳策略的最坏情况，有三部手机进行测试
# 因为题目要求最佳策略，而且有多部手机，那么我们就不能一层一层的摔了
# 最佳策略为找到楼层中间层测试，如果碎了，则表明耐摔指数在中间层之下，没碎则表明在中间层之上，即二分法
# 最坏情况就是两次二分之后（因为三部手机）确定耐摔区间[n,m]，最后一部手机从n层一层一层的网上爬，爬到m-1层

# b[i]表示两部手机最佳策略最坏情况下i次可以测出的最大耐摔指数
b = [0] * 105
# c[i]表示三部手机最佳策略最坏情况下i次可以测出的最大耐摔指数
c = [0] * 105
# n表示楼层，同时也代表最大的耐摔指数
n = int(input())
# i表示测试次数
i = 0

# 我们需要找到c[i]>=n等情况，表示当前测试能够测试出的最大耐摔指数大于最大耐摔指数
while c[i] < n:
    # 如果进入循环说明当前次循环测试不出最大耐摔指数
    i += 1
    # 那么我们就需要考虑最优策略了

    # 先考虑两部手机进行测试的情况，先从层数中间一层进行摔落测试
    # 如果手机碎了，那么说明手机的耐摔指数小于当前楼层
    # 所以还剩一部手机，需要测试i-1层，即从第1层到第i-1层一层一层摔上来，所以还需要测试i-1层
    # 因为无论如何都至少需要测试一次，所以需要加上一个1

    # 如果手机没碎，那么说明手机的耐摔指数大于等于当前楼层
    # 我还剩两部手机，但是我的测试次数少了一次，所以还需b[i-1]
    # 所以b[i]=i-1+1+b[i-1]
    b[i] = i + b[i - 1]

    # 三部手机的情况，在中间层再次进行测试，先摔一部手机
    # 如果手机碎了，那么就变成两部手机再测i-1次的情况，即b[i-1]
    # 如果手机没碎，那么就还是三部手机再测i-1次的情况，即c[i-1]
    # 把他们加起来，再加上第一次测量
    c[i] = c[i - 1] + b[i - 1] + 1
# 输出次数即可
print(i)
